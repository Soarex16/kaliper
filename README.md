<img alt="Kaliper logo" src="https://user-images.githubusercontent.com/9287604/152883473-251213d8-0b8f-46dc-b8e5-8a15f79b285b.png" width="500">

Kaliper is a kotlin compiler plugin for automatic counting shallow size of data classes

Kotlin version: 1.5.0

## Building

You can use prebuilt binaries: 

The project is built with Gradle. Run Gradle to build the project and to 
run the tests using the following command on Unix/macOS:

```shell
./gradlew :plugin:shadowJar
```

or the following command on Windows:

```shell
gradlew :plugin:shadowJar
```

As a result, the jar file with the plugin is located in `plugin/build/libs/kaliper-<VERSION>.jar`

## Usage

If you using gradle for building your kotlin project just add 
following snippet into your `build.gradle.kts`:

```kotlin
val kaliperPluginPath = "..."

tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = freeCompilerArgs + listOf("-Xplugin=${rootDir}/${kaliperPluginPath}",
            "-P", "plugin:arrow.meta.plugin.compiler:generatedSrcOutputDir=${buildDir}")
    }
}
```

## Implementation notes

Due to lack of time and documentation on plugin development, there 
are several tradeoffs in the implementation:

1. The field sizes are defined as follows:
   1. Sizes of basic types are defined according to the 
      documentation https://kotlinlang.org/docs/basic-types.html
   2. Reference types are assumed to be 8 bytes in size. Strictly 
      speaking, this is not the case. The size of the reference field 
      is unknown at compile time (in the case of jvm), a more detailed 
      explanation is here https://stackoverflow.com/a/981130.
2. Plugin emits file for each data class. This is done for two reasons:
   1. To be able to specify a package for each extension method. For example:
    ```kotlin
    // foo.kt
    package foo
    
    data class SomeClass(x: Int)
    
    // bar.kt
    package bar
    
    data class SomeAnotherClass(x: Int)
    ```
    Thus, if we wrote all extension methods in one file, then we could not put
    them in the same packages as the original classes. That is, we would have to 
    additionally import some package generated by the compiler
   2. I did not have time to deal with the library to the end and emit one file for all classes 
3. Plugin generates non-static methods because we can add static extension methods 
   only into companion objects which must be declared inside of class, but we don't want 
   to modify source code
4. Using kotlin version 1.5.0 because in 1.6.0 JetBrains introduced FIR and I have issues with using 
   new Arrow-Meta API (createTypeBindingForReturnType(BindingContext) always returns null) 